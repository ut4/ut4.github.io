{
  
  "0": {
    "title": "",
    "content": "404 . Page not found :( . The requested page could not be found. .",
    "url": "https://ut4.github.io/pike/404.html",
    "relUrl": "/404.html"
  }
  ,"1": {
    "title": "Käyttäjäroolit ja oikeudet",
    "content": "Käyttäjäroolit ja oikeudet . Pike sisältää Pike Auth ACL-luokan, jolla on helppo luoda systeemi, jolla tarkastaa mitä kukin applikaation käyttäjärooli saa, ja ei saa tehdä. . Sisällysluettelo . Peruskäyttö | . Peruskäyttö . Setuppi: . use Pike Auth ACL; $resources = (object) [ &#39;products&#39; =&gt; (object) [ &#39;create&#39; =&gt; 1 &lt;&lt; 1, &#39;edit&#39; =&gt; 1 &lt;&lt; 2, &#39;comment&#39; =&gt; 1 &lt;&lt; 3, ], &#39;reviews&#39; =&gt; (object) [ &#39;post&#39; =&gt; 1 &lt;&lt; 1, &#39;moderate&#39; =&gt; 1 &lt;&lt; 2, ] ]; $userPermissions = (object) [ ACL::ROLE_EDITOR =&gt; (object) [ &#39;products&#39; =&gt; ACL::makePermissions([&#39;comment&#39;, &#39;edit&#39;], $resources-&gt;products), &#39;reviews&#39; =&gt; ACL::makePermissions(&#39;*&#39;, $resources-&gt;reviews), ], ACL::ROLE_CONTRIBUTOR =&gt; (object) [ &#39;products&#39; =&gt; ACL::makePermissions([&#39;comment&#39;], $resources-&gt;products), &#39;reviews&#39; =&gt; ACL::makePermissions([&#39;post&#39;], $resources-&gt;reviews), ] ]; $acl = new ACL; $acl-&gt;setRules((object)[&#39;resources&#39; =&gt; $resources, &#39;userPermissions&#39; =&gt; $userPermissions]); . Käyttäminen: . $acl-&gt;can(ACL::ROLE_EDITOR, &#39;create&#39;, &#39;products&#39;); // false $acl-&gt;can(ACL::ROLE_EDITOR, &#39;edit&#39;, &#39;products&#39;); // true $acl-&gt;can(ACL::ROLE_EDITOR, &#39;comment&#39;, &#39;products&#39;); // true $acl-&gt;can(ACL::ROLE_EDITOR, &#39;post&#39;, &#39;reviews&#39;); // true $acl-&gt;can(ACL::ROLE_EDITOR, &#39;moderate&#39;, &#39;reviews&#39;); // true $acl-&gt;can(ACL::ROLE_CONTRIBUTOR, &#39;create&#39;, &#39;products&#39;); // false $acl-&gt;can(ACL::ROLE_CONTRIBUTOR, &#39;edit&#39;, &#39;products&#39;); // false $acl-&gt;can(ACL::ROLE_CONTRIBUTOR, &#39;comment&#39;, &#39;products&#39;); // true $acl-&gt;can(ACL::ROLE_CONTRIBUTOR, &#39;post&#39;, &#39;reviews&#39;); // true $acl-&gt;can(ACL::ROLE_CONTRIBUTOR, &#39;moderate&#39;, &#39;reviews&#39;); // false . Oletuskäyttäytyminen: . // false, jos role|action|resource ei olemassa $acl-&gt;can(NONEXISTING_ROLE, &#39;post&#39;, &#39;reviews&#39;); // false $acl-&gt;can(ACL::ROLE_EDITOR, &#39;nonExistingAction&#39;, &#39;reviews&#39;); // false $acl-&gt;can(ACL::ROLE_EDITOR, &#39;post&#39;, &#39;nonExistingResource&#39;); // false // true, jos kyseessä super-admin $acl-&gt;can(ACL::ROLE_SUPER_ADMIN, &#39;nonExistingAction&#39;, &#39;reviews&#39;); // true $acl-&gt;can(ACL::ROLE_SUPER_ADMIN, &#39;post&#39;, &#39;nonExistingResource&#39;); // true $acl-&gt;can(ACL::ROLE_SUPER_ADMIN, &#39;kissat koiria&#39;, &#39;gfffögkfhjd&#39;); // true .",
    "url": "https://ut4.github.io/pike/acl.html",
    "relUrl": "/acl.html"
  }
  ,"2": {
    "title": "Autentikaatio",
    "content": "Autentikaatio . Pike sisältää autentikaatiomoduulin, jolla on yksi julkinen luokka - Pike Auth Authenticator. Autentikaattori käyttää tietokantaa pitkäaikaisen, ja php-natiivia sessiota lyhytaikaisen tiedon tallennukseen. Tallennusmekanismit ei ole vielä kustomoitavissa. . use Pike Auth Authenticator; class MyCtrl { public function __construct(Authenticator $auth) { $this-&gt;auth = $auth; } // tai.. public function myMethod(Authenticator $auth) { // tee jotain $auth:llä } } . Sisällysluettelo . Käyttäjän kirjaaminen sisään | Käyttäjän kirjautumistietojen haku | Käyttäjän kirjaaminen ulos | Käyttäjän salasanan palautus (1. vaihe) | Käyttäjän salasanan palautus (2. vaihe) | . Käyttäjän kirjaaminen sisään . try { $mySerializeUserToSession = function ( stdClass $user) { return (object) [&#39;id&#39; =&gt; $user-&gt;id, &#39;role&#39; =&gt; (int) $user-&gt;role]; }; $auth-&gt;login(&#39;username&#39;, &#39;password&#39;, $mySerializeUserToSession); // ok, käyttäjä on nyt kirjattu sessioon } catch (PikeException $e) { if ($e-&gt;getCode() === Authenticator::INVALID_CREDENTIAL) ; // Käyttäjätunnus tai salasana väärin, tee jotain else ; // Jokin muu poikkeus, tee jotain } . Käyttäjän kirjautumistietojen haku . $myDataFromSession = $auth-&gt;getIdentity(); if ($myDataFromSession) echo $myDataFromSession-&gt;id; // bf789e1e-c99... else ; // Kirjautumistietoja ei löytynyt sessiosta . Käyttäjän kirjaaminen ulos . $auth-&gt;logout(); // Ok, kirjautumistiedot poistettiin sessiosta . Käyttäjän salasanan palautus (1. vaihe) . try { $userNameOrEmail = &#39;username&#39;; $myMakeEmailSettings = function ($user, $resetKey, $settings) { // echo $settings-&gt;fromAddress; // &#39;&#39; echo $settings-&gt;fromName; // &#39;&#39; echo $settings-&gt;toAddress; // &lt;käyttäjän $userNameOrEmail email&gt; echo $settings-&gt;toName; // &lt;käyttäjän $userNameOrEmail username&gt; echo $settings-&gt;subject; // &#39;&#39; echo $settings-&gt;body; // &#39;&#39; // $settings-&gt;fromAddress = &#39;root@my-site.com&#39;; $settings-&gt;subject = &#39;Salasanan palautus&#39;; $settings-&gt;body = sprintf( &#39;Vaihda salasana osoitteessa: %s. Linkki on voimassa %d tuntia.&#39;, &quot;my-site.com/my-finalize-password-route/{$resetKey}&quot;, intval(Authenticator::RESET_KEY_EXPIRATION_SECS / 60 / 60) ); }; $auth-&gt;requestPasswordReset($userNameOrEmail, $myMakeEmailSettings); // Ok, salasanan resetointipyyntötiedot tallennettiin $userNameOrEmail- // käyttäjän tietoihin tietokantaan, ja lähetettiin myMakeEmailSettings- // closuressa määritelty sähköposti } catch (PikeException $e) { if ($e-&gt;getCode() === Authenticator::INVALID_CREDENTIAL) ; // Käyttäjää $userNameOrEmail ei löytynyt elseif ($e-&gt;getCode() === Authenticator::FAILED_TO_FORMAT_MAIL) ; // myMakeEmailSettings jätti jotain täyttämättä elseif ($e-&gt;getCode() === Authenticator::FAILED_TO_SEND_MAIL) ; // sähköpostin lähetys epäonnistui else ; // Jokin muu poikkeus, tee jotain } . Käyttäjän salasanan palautus (2. vaihe) . try { $auth-&gt;finalizePasswordReset(&#39;&lt;key&gt;&#39;, &#39;email&#39;, &#39;newPassword&#39;); // Ok, uusi salasana päivitettiin tietokantaan ja resetointipyyntötiedot // tyhjennettiin tietokannasta } catch (PikeException $e) { if ($e-&gt;getCode() === Authenticator::INVALID_CREDENTIAL) { ; // resetointiavainta ei ollut olemassa, se oli vanhentunut, tai // $email ei täsmännyt else ; // Jokin muu poikkeus, tee jotain } .",
    "url": "https://ut4.github.io/pike/authentication.html",
    "relUrl": "/authentication.html"
  }
  ,"3": {
    "title": "Reittien käyttäjäoikeudet",
    "content": "Reittien käyttäjäoikeudet . Tämä esimerkki demonstroi miten voit hylätä tai hyväksyä HTTP-pyyntöjä käyttäjän roolin perusteella käyttämällä Pike Auth ACL-luokkaa, reittimiddlewarea, ja reittikonteksteja. . Esimerkin koodi löytyy kokonaisuudessaan github.com/ut4/pike/tree/master/examples-kansiosta. . . Sisällysluettelo . Step 1: Reittimiddlewaren lisääminen applikaatioon | Step 2: Reittimiddlewaren implementointi | Step 3: ACL-informaation lisääminen reitteihin | Testipyynnöt ja vastaukset Roolille ACL::ROLE_CONTRIBUTOR | Roolille ACL::ROLE_AUTHOR | Roolille ACL::ROLE_SUPER_ADMIN | | Step 1: Reittimiddlewaren lisääminen applikaatioon . index.php (examples/authorizing-routes.php) . ... $myModules = [AuthorizingRoutes MyAuthModule::class, muut reitit...]; ... $app-&gt;handleRequest($req); . Step 2: Reittimiddlewaren implementointi . Katso myös. Käyttäjäroolit ja oikeudet. . AuthorizingRoutes/MyAuthModule.php . ... abstract class MyAuthModule { /** * @param stdClass $ctx { Pike Router router} */ public static function init( stdClass $ctx) { $ctx-&gt;acl = new Pike Auth ACL; $ctx-&gt;acl-&gt;setRules(self::makeMyAclRules()); // $ctx-&gt;router-&gt;on(&#39;*&#39;, function ($req, $res, $next) use ($ctx) { // Tämä tulisi normaalisti sessiosta ($ctx-&gt;auth-&gt;getIdentity()-&gt;role) $userRole = LOGGED_IN_USER_ROLE; // ks. Step 3 [$action, $resource] = explode(&#39;:&#39;, $req-&gt;routeInfo-&gt;myCtx); if (!$ctx-&gt;acl-&gt;can($userRole, $action, $resource)) $res-&gt;status(403)-&gt;json([&#39;err&#39; =&gt; &#39;Not permitted&#39;]); else $next(); }); } /** * @return stdClass */ private static function makeMyAclRules(): stdClass { // Nämä tulisi normaalisti esim. tiedostosta tai tietokannasta. $resources = (object) [ &#39;products&#39; =&gt; ..., &#39;reviews&#39; =&gt; ... ]; $userPermissions = (object) [ ACL::ROLE_EDITOR =&gt; (object) [ &#39;products&#39; =&gt; ..., &#39;reviews&#39; =&gt; ..., ], ACL::ROLE_CONTRIBUTOR =&gt; (object) [ &#39;products&#39; =&gt; ..., &#39;reviews&#39; =&gt; ..., ] ]; return (object) [ &#39;resources&#39; =&gt; $resources, &#39;userPermissions&#39; =&gt; $userPermissions ]; } } . Step 3: ACL-informaation lisääminen reitteihin . AuthorizingRoutes/Product/ProductModule.php | AuthorizingRoutes/Review/ReviewModule.php | . ... abstract class ProductModule { /** * @param stdClass $ctx { Pike Router router} */ public static function init( stdClass $ctx) { $ctx-&gt;router-&gt;map(&#39;POST&#39;, &#39;/products&#39;, [ProductController::class, &#39;handleCreateProduct&#39;, &#39;create:products&#39;] ); $ctx-&gt;router-&gt;map(&#39;PUT&#39;, &#39;/products/[i:productId]&#39;, [ProductController::class, &#39;handleEditProduct&#39;, &#39;edit:products&#39;] ); $ctx-&gt;router-&gt;map(&#39;POST&#39;, &#39;/products/[i:productId]/comment&#39;, [ProductController::class, &#39;handleAddComment&#39;, &#39;comment:products&#39;] ); } } ... sama setti Review/ReviewModule.php:ssa . Testipyynnöt ja vastaukset . Esimerkin applikaatiota voi testata esimerkiksi php:hen bundlatulla dev-serverillä: . Aja cd examples | Aja php -S localhost:8080 | Päivitä authorizing-routers.php -tiedoston define(&#39;LOGGED_IN_USER_ROLE&#39;, &lt;arvo&gt;) | . Roolille ACL::ROLE_CONTRIBUTOR . POST &#39;http://localhost:8080/authorizing-routes.php?q=/products&#39; -&gt; &#39;{&quot;err&quot;:&quot;Not permitted&quot;}&#39; POST &#39;http://localhost:8080/authorizing-routes.php?q=/products/1/comment&#39; -&gt; &#39;{&quot;ok&quot;:&quot;ok&quot;}&#39; PUT &#39;http://localhost:8080/authorizing-routes.php?q=/products/1&#39; -&gt; &#39;{&quot;err&quot;:&quot;Not permitted&quot;}&#39; POST &#39;http://localhost:8080/authorizing-routes.php?q=/reviews&#39; -&gt; &#39;{&quot;insertId&quot;:1}&#39; PUT &#39;http://localhost:8080/authorizing-routes.php?q=/reviews/1/approve-or-reject&#39; -&gt; &#39;{&quot;ok&quot;:&quot;ok&quot;}&#39; . Roolille ACL::ROLE_AUTHOR . POST &#39;http://localhost:8080/authorizing-routes.php?q=/products&#39; -&gt; &#39;{&quot;err&quot;:&quot;Not permitted&quot;}&#39; POST &#39;http://localhost:8080/authorizing-routes.php?q=/products/1/comment&#39; -&gt; &#39;{&quot;ok&quot;:&quot;ok&quot;}&#39; PUT &#39;http://localhost:8080/authorizing-routes.php?q=/products/1&#39; -&gt; &#39;{&quot;ok&quot;:&quot;ok&quot;}&#39; POST &#39;http://localhost:8080/authorizing-routes.php?q=/reviews&#39; -&gt; &#39;{&quot;insertId&quot;:1}&#39; PUT &#39;http://localhost:8080/authorizing-routes.php?q=/reviews/1/approve-or-reject&#39; -&gt; &#39;{&quot;err&quot;:&quot;Not permitted&quot;}&#39; . Roolille ACL::ROLE_SUPER_ADMIN . POST|PUT &#39;&lt;mikäTahansaReitti&gt;&#39; -&gt; &#39;{&quot;ok&quot;:&quot;ok&quot;}&#39; .",
    "url": "https://ut4.github.io/pike/examples/authorizing-routes.html",
    "relUrl": "/examples/authorizing-routes.html"
  }
  ,"4": {
    "title": "Tietokanta",
    "content": "Tietokanta . Pikessä tietokantakyselyt suoritetaan Pike Db-luokalla, joka on on ohut wräpperi PDO-abstraktion ympärille. . use Pike Db; class MyCtrl { public function __construct(Db $db) { $this-&gt;db = $db; } // tai.. public function myMethod(Db $db) { // tee jotain $db:llä } } . Sisällysluettelo . Käyttöönotto (MariaDb/MySQL) index.php | MyBootstrapModule.php | | Datan insertointi | Datan hakeminen, useita rivejä | Datan hakeminen, yksi rivi | Datan päivittäminen | Datan poistaminen | . Käyttöönotto (MariaDb/MySQL) . Pike Db:n konfigrointiin tarvitaan kolme asiaa: . Pike App::create():een passattu $config, jossa vähintään db.host =&gt; &#39;myval&#39; | Pike App::create():een passattu $ctx, jossa &#39;db&#39; =&gt; Pike App::MAKE_AUTOMATICALLY | $db-&gt;open()-kutsu | . Näiden jälkeen Pike Db injektoituu minkä tahansa kontrollerin konstruktoriin tai metodiin type-hinttien perusteella (ks. examples/hello-world.md mikäli et muista miten tämä tapahtuu). Pike Db -luokasta luodaan vain yksi instanssi, ks. Auryn Injector-&gt;share(). . Esimerkki: . index.php . $ctx = (object) [ Pike App::SERVICE_DB =&gt; Pike App::MAKE_AUTOMATICALLY]; // tai $ctx = (object) [&#39;db&#39; =&gt; &#39;@auto&#39;]; $config = [ &#39;db.host&#39; =&gt; &#39;127.0.0.1&#39;, // oletus &#39;127.0.0.1&#39; &#39;db.database&#39; =&gt; &#39;new2&#39;, // oletus &#39;&#39; &#39;db.user&#39; =&gt; &#39;devuser&#39;, // oletus &#39;&#39; &#39;db.pass&#39; =&gt; &#39;qweqwe&#39;, // oletus &#39;&#39; &#39;db.tablePrefix&#39; =&gt; &#39;rad_&#39;, // oletus &#39;&#39; &#39;db.charset&#39; =&gt; &#39;utf8&#39;, // oletus &#39;utf8&#39; ]; // tai $config = __DIR__ . &#39;/config.php&#39;; // jossa &lt;?php return [...]; $app = RadCms App::create([MyBootstrapModule::class], $config, $ctx); $app-&gt;handleRequest(...); . MyBootstrapModule.php . abstract class MyBootstrapModule { /** * @param stdClass $ctx { Pike Db db, Pike Router router} */ public static function init( stdClass $ctx) { try { $ctx-&gt;db-&gt;open(); } catch ( Pike PikeException $e) { // Tee jotain } } } . Datan insertointi . $data = (object) [&#39;foo&#39; =&gt; &#39;value&#39;, &#39;bar&#39; =&gt; &#39;another value&#39;]; [$qs, $vals, $columns] = Pike DbUtils::makeInsertBinders($data); try { $insertId = $db-&gt;exec(&quot;INSERT INTO `Products` ({$columns}) VALUES ({$qs})&quot;, $vals); if ($insertId &gt; 0) ; // ok else ; // Tee jotain } catch ( PDOException $e) { ; // Handlaa tilanne } . Datan hakeminen, useita rivejä . try { $rows = $db-&gt;fetchAll(&quot;SELECT `foo`,`bar` FROM Products WHERE `id`&lt;?&quot;, [3]); if ($rows) echo $rows[0][&#39;foo&#39;]; // &#39;value&#39; else ; // tee jotain } catch ( PDOException $e) { ; // Handlaa tilanne } . Datan hakeminen, yksi rivi . try { $row = $db-&gt;fetchOne(&quot;SELECT `foo`,`bar` FROM Products WHERE `id`=?&quot;, [1]); if ($row) echo $rows[&#39;foo&#39;]; // &#39;value&#39; else ; // tee jotain } catch ( PDOException $e) { ; // Handlaa tilanne } . Datan päivittäminen . $data = (object) [&#39;foo&#39; =&gt; &#39;value&#39;, &#39;bar&#39; =&gt; &#39;another value&#39;]; [$columns, $vals] = Pike DbUtils::makeUpdateBinders($data); try { $numAffectedRows = $db-&gt;exec(&quot;UPDATE `Products` SET {$columns} WHERE `id`=?&quot;, array_merge($vals, [1])); if ($numAffectedRows &gt; 0) ; // ok else ; // Tee jotain } catch ( PDOException $e) { ; // Handlaa tilanne } . Datan poistaminen . try { $numAffectedRows = $db-&gt;exec(&quot;DELETE FROM Products WHERE `id`=?&quot;, [1]); if ($numAffectedRows) ; // ok else ; // tee jotain } catch ( PDOException $e) { ; // Handlaa tilanne } .",
    "url": "https://ut4.github.io/pike/database.html",
    "relUrl": "/database.html"
  }
  ,"5": {
    "title": "Esimerkit",
    "content": "Esimerkit . Kokoelma applikaatioita, jotka näyttää mitä voit tehdä Pikellä. . Sisällysluettelo . Hello world | Reittien mappaus | Reittien käyttäjäoikeudet |",
    "url": "https://ut4.github.io/pike/examples/examples.html",
    "relUrl": "/examples/examples.html"
  }
  ,"6": {
    "title": "Tiedostojen hallinta",
    "content": "Tiedostot . Pike FileSystem on abstraktio yleisimpien php-natiivien tiedostonhallintafunktioiden (is_dir(), file_get_contents()) ympärille. . use Pike FileSystemInterface; class MyCtrl { public function __construct(FileSystemInterface $fs) { $this-&gt;fs = $fs; } // tai.. public function myMethod(FileSystemInterface $fs) { // tee jotain $fs:llä } } . Sisällysluettelo . Tiedoston luominen, tiedostoon kirjoittaminen | Tiedoston lukeminen | Tiedoston poistaminen | Tiedoston kopioiminen | Kansion luominen | Kansion poistaminen | Tiedostopolun tarkistaminen | Kansiopolun tarkistaminen | Kansion sisällön lukeminen (ei-rekursiivinen) | Kansion sisällön lukeminen (rekursiivinen) | Tiedoston viimeisimmän modifikaation lukeminen | Polun normalisointi | . Tiedoston luominen, tiedostoon kirjoittaminen . $numBytesWritten = $fs-&gt;write(__DIR__ . &#39;/tiedosto.txt&#39;, &#39;Sisältö&#39;); if ($numBytesWritten !== false) ; // ok else ; // Handlaa failure . Tiedoston lukeminen . $contents = $fs-&gt;read(__DIR__ . &#39;/tiedosto.txt&#39;); if ($contents !== false) ; // ok else ; // Handlaa failure . Tiedoston poistaminen . $ok = $fs-&gt;unlink(__DIR__ . &#39;/tiedosto.txt&#39;); if ($ok) ; // ok else ; // Handlaa failure . Tiedoston kopioiminen . Kohdepolun kansio tulee olla olemassa. Jos kohdetiedosto on jo olemassa, se ylikirjoitetaan. . $ok = $fs-&gt;copy(__DIR__ . &#39;/tiedosto.txt&#39;, __DIR__ . &#39;/copied.txt&#39;); if ($ok) ; // ok else ; // Handlaa failure . Kansion luominen . $perms = 0755; // oletus 0777 $recursive = false; // oletus true $ok = $fs-&gt;mkDir(__DIR__ . &#39;/kansio&#39;, $perms, $recursive); if ($ok) ; // ok else ; // Handlaa failure . Kansion poistaminen . $ok = $fs-&gt;rmDir(__DIR__ . &#39;/kansio&#39;); if ($ok) ; // ok else ; // Handlaa failure . Tiedostopolun tarkistaminen . $isFile = $fs-&gt;isFile(__DIR__ . &#39;/tiedosto.txt&#39;); if ($isFile) ; // on tiedosto else ; // ei ole tiedosto . Kansiopolun tarkistaminen . $isDir = $fs-&gt;isDir(__DIR__ . &#39;/kansio&#39;); if ($isDir) ; // on kansio else ; // ei ole kansio . Kansion sisällön lukeminen (ei-rekursiivinen) . $globPattern = &#39;*.txt&#39;; // oletus &#39;*&#39;, $globFlags = null; // oletus GLOB_ERR $fullFilePaths = $fs-&gt;readDir(__DIR__ . &#39;/kansio&#39;, $globPattern, $globFlags); if ($fullFilePaths !== false) echo $fullFilePaths[0]; // /htdocs/projekti/kansio/foo.txt else ; // Handlaa failure . Kansion sisällön lukeminen (rekursiivinen) . $regexpPattern = &#39;/^.* .(js|css)$/&#39;; $fullFilePaths = $fs-&gt;readDirRecursive(__DIR__ . &#39;/kansio&#39;, $regexpPattern); if ($fullFilePaths !== false) echo $fullFilePaths[0]; // /htdocs/projekti/kansio/alikansio/foo.js else ; // Handlaa failure . Tiedoston viimeisimmän modifikaation lukeminen . $unixTime = $fs-&gt;lastModTime(__DIR__ . &#39;/tiedosto.txt&#39;); if ($unixTime !== false) ; // Tee jotain $unixTimella else ; // Handlaa failure . Polun normalisointi . $notNormalized = __DIR__ . &#39;/foo/&#39;; // c: kansio alikansio/foo/ $normalized = FileSystem::normalizePath($notNormalized); echo $normalized; // c:/kansio/alikansio/foo .",
    "url": "https://ut4.github.io/pike/filesystem.html",
    "relUrl": "/filesystem.html"
  }
  ,"7": {
    "title": "Hello world",
    "content": "Hello world -esimerkkiapplikaatio . Tässä tiedostossa Hello World -applikaatio joka demonstroi miten: . Pike-applikaatio laitetaan liikkeelle (index.php) | HTTP-reittejä rekisteröidään, koodia voi jaotella ryhmiin (SomeModule.php) | HTTP-pyyntöjen parametreihin ja POST-dataan pääse käsiksi, miten selaimelle lähetetään tietoa takaisin (SomeController.php) | Auryn Injector injektoi automaattisesti luokat (SomeClass.php) kontrollereihin type-hinttien perusteella | . Esimerkin koodi löytyy kokonaisuudessaan github.com/ut4/pike/tree/master/examples-kansiosta. . . Sisällysluettelo . index.php (examples/hello-world.php) | HelloWorld/SomeModule.php | HelloWorld/SomeController.php | HelloWorld/SomeClass.php | Esimerkkipyynnöt | index.php (examples/hello-world.php) . &lt;?php $loader = require dirname(__DIR__) . &#39;/vendor/autoload.php&#39;; $loader-&gt;addPsr4(&#39;Me HelloWorld &#39;, __DIR__ . &#39;/HelloWorld/src&#39;); $myModules = [ Me HelloWorld SomeModule::class]; $app = Pike App::create($myModules); $req = Pike Request::createFromGlobals(&#39;&#39;, $_GET[&#39;q&#39;] ?? &#39;/&#39;); $app-&gt;handleRequest($req); . HelloWorld/SomeModule.php . &lt;?php declare(strict_types=1); namespace Me HelloWorld; abstract class SomeModule { /** * @param stdClass $ctx { Pike Router router} */ public static function init( stdClass $ctx): void { // ks. examples/mapping-routes.md $ctx-&gt;router-&gt;map(&#39;GET&#39;, &#39;/some-route&#39;, [SomeController::class, &#39;handleSomeRoute&#39;] ); $ctx-&gt;router-&gt;map(&#39;POST&#39;, &#39;/another-route/[*:someParam]&#39;, [SomeController::class, &#39;handleAnotherRoute&#39;] ); } } . HelloWorld/SomeController.php . &lt;?php declare(strict_types=1); namespace Me HelloWorld; use Pike Response; use Pike Request; class SomeController { /** * @param Me HelloWorld SomeClass $myClass * @param Pike Response $res */ public function handleSomeRoute(SomeClass $myClass, Response $res): void { $data = $myClass-&gt;doSomething(); if ($data) $res-&gt;json([$data]); else $res-&gt;status(500)-&gt;json([&#39;err&#39; =&gt; 1]); } /** * @param Pike Request $req * @param Pike Response $res */ public function handleAnotherRoute(Request $req, Response $res): void { $res-&gt;json([&#39;yourParamWas&#39; =&gt; $req-&gt;params-&gt;someParam, &#39;requestBodyWas&#39; =&gt; $req-&gt;body]); } } . HelloWorld/SomeClass.php . &lt;?php declare(strict_types=1); namespace Me HelloWorld; class SomeClass { /** * @return string|null */ public function doSomething(): ?string { return &#39;Hello&#39;; } } . Esimerkkipyynnöt . Esimerkin applikaatiota voi testata esimerkiksi php:hen bundlatulla dev-serverillä: . cd examples | php -S localhost:8080 | some-route url: http://localhost:8080/hello-world.php?q=/some-route | method: GET | . | another-route url: http://localhost:8080/hello-world.php?q=/another-route/foo | method: POST | body: {“any”: “thing”} | header: Content-Type: application/json | . | .",
    "url": "https://ut4.github.io/pike/examples/hello-world.html",
    "relUrl": "/examples/hello-world.html"
  }
  ,"8": {
    "title": "Koti",
    "content": "Pike docs . Minimalistinen dokumentaatio minimalistiselle frameworkille. Työn alla. . Sisällysluettelo . Esimerkit Hello world | Reittien mappaus | Reittien käyttäjäoikeudet | | Tietokanta | Tiedostojen hallinta | Datan validointi | Käyttäjäroolit ja oikeudet | Autentikaatio | Testaus |",
    "url": "https://ut4.github.io/pike/",
    "relUrl": "/"
  }
  ,"9": {
    "title": "Reittien mappaus",
    "content": "Reittien mappaus . Tämä esimerkki demonstroi: . , että Pikessä reitit määritellään moduulien init()-tiedostossa | , että reitteihin tulee määritellä [SomeController::class, &#39;methodName&#39;] | , että reitille voi määritellä nimen, ja kontekstin | , middleware | , miten reittiin määritelty tieto päätyy Pike Request -olioon | . Pike käyttää reititykseen AltoRouteria, jonka dokumentaatio löytyy osoitteesta altorouter.com/usage/mapping-routes.html. AltoRouterin Match Types:ien ([i:myId]) lisäksi voit käyttää myös Piken omia. . Esimerkin koodi löytyy kokonaisuudessaan github.com/ut4/pike/tree/master/examples-kansiosta. . . Sisällysluettelo . MappingRoutes/Module.php | MappingRoutes/Controller.php | Esimerkkikutsut ja vastaukset route-a | route-b | route-c | route-d | | Piken rekisteröimät Match Typet | MappingRoutes/Module.php . &lt;?php declare(strict_types=1); namespace Me MappingRoutes; abstract class Module { /** * @param stdClass $ctx { Pike Router router} */ public static function init( stdClass $ctx) { $ctx-&gt;router-&gt;map(&#39;GET&#39;, &#39;/route-a&#39;, [Controller::class, &#39;handleRouteA&#39;] ); $ctx-&gt;router-&gt;map(&#39;GET&#39;, &#39;/route-b/[i:myNumber]/[w:myOptionalSlug]?&#39;, [Controller::class, &#39;handleRouteB&#39;] ); $ctx-&gt;router-&gt;map(&#39;GET&#39;, &#39;/route-c/[foo|bar:fooOrBar]&#39;, [Controller::class, &#39;handleRouteC&#39;], &#39;nameOfRouteC&#39; ); $ctx-&gt;router-&gt;map(&#39;POST&#39;, &#39;/route-d/[i:id]&#39;, [Controller::class, &#39;handleRouteC&#39;, [&#39;my&#39; =&gt; &#39;context&#39;]] ); /* $ctx-&gt;router-&gt;map(&#39;GET&#39;, &#39;/some-route&#39;, &#39;notAnArray&#39;); // PikeException $ctx-&gt;router-&gt;map(&#39;GET&#39;, &#39;/some-route&#39;, [&#39;incomplete&#39;]); // PikeException $ctx-&gt;router-&gt;map(&#39;GET&#39;, &#39;/some-route&#39;); // PikeException */ } } . MappingRoutes/Controller.php . &lt;?php declare(strict_types=1); namespace Me MappingRoutes; use Pike Response; use Pike Request; class Controller { public function handleRouteA(Request $req, Response $res): void { $res-&gt;json((object) [ &#39;params&#39; =&gt; $req-&gt;params, &#39;body&#39; =&gt; $req-&gt;body, &#39;routeInfo&#39; =&gt; $req-&gt;routeInfo, ]); } // loput handlerit identtisiä handleRouteA:n kanssa // ... } . Esimerkkikutsut ja vastaukset . Esimerkin applikaatiota voi testata esimerkiksi php:hen bundlatulla dev-serverillä: . cd examples | php -S localhost:8080 | . route-a . GET &#39;http://localhost:8080/mapping-routes.php?q=/route-a&#39; $req-&gt;params; // {} $req-&gt;body; // {} $req-&gt;routeInfo; // {&quot;myCtx&quot;:null,&quot;name&quot;:null} . route-b . GET &#39;http://localhost:8080/mapping-routes.php?q=/route-b/1/foo-bar&#39; $req-&gt;params; // {&quot;myNumber&quot;:&quot;1&quot;,&quot;myOptionalSlug&quot;:&quot;foo-bar&quot;} $req-&gt;body; // {} $req-&gt;routeInfo; // {&quot;myCtx&quot;:null,&quot;name&quot;:null} GET &#39;http://localhost:8080/mapping-routes.php?q=/route-b/2&#39; $req-&gt;params; // {&quot;myNumber&quot;:&quot;1&quot;} $req-&gt;body; // {} $req-&gt;routeInfo; // {&quot;myCtx&quot;:null,&quot;name&quot;:null} GET &#39;http://localhost:8080/mapping-routes.php?q=/route-b/3/not-allœw€d&#39; -&gt; PikeException: No match GET &#39;http://localhost:8080/mapping-routes.php?q=/route-b/not-a-number&#39; -&gt; PikeException: No match . route-c . GET &#39;http://localhost:8080/mapping-routes.php?q=/route-c/foo&#39; -&gt; $req-&gt;params; // {&quot;fooOrBar&quot;:&quot;foo&quot;} $req-&gt;body; // {} $req-&gt;routeInfo; // {&quot;myCtx&quot;:null,&quot;name&quot;:&quot;nameOfRouteC&quot;} GET &#39;http://localhost:8080/mapping-routes.php?q=/route-c/baz&#39; -&gt; PikeException: No match . route-d . POST &#39;http://localhost:8080/mapping-routes.php?q=/route-d/1&#39; (Headers): `Content-Type: application/json` (Body): `{&quot;foo&quot;:&quot;bar&quot;}` // -&gt; $req-&gt;params; // {&quot;id:&quot;1&quot;} $req-&gt;body; // {&quot;foo&quot;:&quot;bar&quot;} $req-&gt;routeInfo; // {&quot;myCtx&quot;:{&quot;my&quot;:&quot;context&quot;},&quot;name&quot;:null} POST &#39;http://localhost:8080/mapping-routes.php?q=/route-d/2&#39; (Headers): `Content-Type: application/json` (Body): none // -&gt; $req-&gt;params; // {&quot;id:&quot;2&quot;} $req-&gt;body; // {} $req-&gt;routeInfo; // {&quot;myCtx&quot;:{&quot;my&quot;:&quot;context&quot;},&quot;name&quot;:null} POST &#39;http://localhost:8080/mapping-routes.php?q=/route-d/3&#39; (Headers): none (Body): `{&quot;bar&quot;:&quot;baz&quot;}` // -&gt; $req-&gt;params; // {&quot;id:&quot;3&quot;} $req-&gt;body; // {} $req-&gt;routeInfo; // {&quot;myCtx&quot;:{&quot;my&quot;:&quot;context&quot;},&quot;name&quot;:null} POST &#39;http://localhost:8080/mapping-routes.php?q=/route-d/d&#39; // -&gt; PikeException: No match . Piken rekisteröimät Match Typet . $router-&gt;addMatchTypes([&#39;w&#39; =&gt; &#39;[0-9A-Za-z_-]++&#39;]); .",
    "url": "https://ut4.github.io/pike/examples/mapping-routes.html",
    "relUrl": "/examples/mapping-routes.html"
  }
  ,"10": {
    "title": "Testaus",
    "content": "Testaus . Pike TestUtils on kokoelma luokkia jotka auttaa Pike-applikaation testauksessa. . Sisällysluettelo . HTTP-reittien testaus Esimerkki, HttpTestUtils-&gt;sendRequest() | Esimerkki, HttpTestUtils-&gt;sendResponseBodyCapturingRequest() | | . HTTP-reittien testaus . Pikessä kontrollerien testaus suoritetaan Pike TestUtils HttpTestUtils-traitin metodeilla sendRequest(), ja sendResponseBodyCapturingRequest(), jotka tarvitsee kolme asiaa: . Konfiguroitu Pike-applikaatio ( Pike App-olio) | Testattava reitti ( Pike Request-olio) | Odotettu vastaus ( PHPUnit Framework MockObject MockObject&lt; Pike Response&gt;-olio) | . Esimerkki, HttpTestUtils-&gt;sendRequest() . &lt;?php ... use PHPUnit Framework TestCase; use Pike Request; use Pike TestUtils HttpTestUtils; class MyControllerTest extends TestCase { // 1. Sisällytä trait use HttpTestUtils; public function testSomeRouteReturnsFoo(): void { // 2. Luo applikaatio-olio $config = []; $ctx = new stdClass; $app = $this-&gt;makeApp([MyApp::class, &#39;create&#39;], $config, $ctx); // 3. Luo olio testattavalle reitille $body = null; $files = null; $serverVars = null; $req = new Request(&#39;/some-route&#39;, &#39;GET&#39;, $body, $files, $serverVars); // 4. Luo olio odotetulle vastaukselle $expectedBody = (object) [&#39;message&#39; =&gt; &#39;foo&#39;]; $expectedStatusCode = 200; $expectedContentType = &#39;json&#39;; $res = $this-&gt;createMockResponse($expectedBody, $expectedStatusCode, $expectedContentType); // 5. Suorita testi $this-&gt;sendRequest($req, $res, $app); } } . Esimerkki, HttpTestUtils-&gt;sendResponseBodyCapturingRequest() . Jos haluat suorittaa manuaalisesti assertioita kontrollerin lähettämään ($res-&gt;send(...)) vastaukseen, käytä sendResponseBodyCapturingRequest()-metodia. Vastaus tallentuu $state-olion kenttään actualResponseBody merkkijonona. . &lt;?php ... class MyControllerTest extends TestCase { // 1. Sisällytä trait ... public function testAnotherRouteReturnsBar(): void { // 2. Luo applikaatio-olio $config = []; $ctx = new stdClass; $app = $this-&gt;makeApp([MyApp::class, &#39;create&#39;], $config, $ctx); // 3. Luo olio testattavalle reitille $req = new Request(&#39;/another-route&#39;, &#39;GET&#39;); // 4. Luo olio tulokselle $res = $this-&gt;createMock(Response::class); // 5. Suorita pyyntö $state = (object) [&#39;actualResponseBody&#39; =&gt; null]; $this-&gt;sendResponseBodyCapturingRequest($req, $res, $app, $state); // 6. Assertoi $this-&gt;assertIsString($state-&gt;actualResponseBody); $expected = json_encode((object) [&#39;message&#39; =&gt; &#39;bar&#39;]); $this-&gt;assertEquals($expected, $state-&gt;actualResponseBody); } } .",
    "url": "https://ut4.github.io/pike/testing.html",
    "relUrl": "/testing.html"
  }
  ,"11": {
    "title": "Datan validointi",
    "content": "Datan validointi . Pike sisältää luokat olioiden, ja yksittäisten arvojen validoimiseen. . Sisällysluettelo . Olioiden validointi | Yksittäisten arvojen validointi | Custom one-time -validaattorit | Oletusvalidaattorit rule(‘type’, ‘string’|’int’|’array’|’bool’|’float’|’object’ $expectedDataType) | rule(‘minLength’, int $minLength) | rule(‘maxLength’, int $maxLength) | rule(‘min’, int $min) | rule(‘max’, int $max) | rule(‘in’, array $listOfValues) | rule(‘identifier’) | | . Olioiden validointi . $object = (object) [ &#39;foo&#39; =&gt; &#39;value&#39;, &#39;bar&#39; =&gt; (object) [&#39;key&#39; =&gt; &#39;another value&#39;], &#39;baz&#39; =&gt; [ (object) [&#39;key&#39; =&gt; &#39;inside array&#39;], (object) [&#39;key&#39; =&gt; &#39;inside array&#39;], ] ]; $errors = ( Pike Validation::makeObjectValidator()) -&gt;rule(&#39;foo&#39;, &#39;type&#39;, &#39;int&#39;) -&gt;rule(&#39;optional?&#39;, &#39;type&#39;, &#39;int&#39;) -&gt;rule(&#39;bar.key&#39;, &#39;minLength&#39;, 1) -&gt;rule(&#39;baz.*.key&#39;, &#39;in&#39;, [&#39;a&#39;, &#39;b&#39;]) -&gt;validate($object); if (!$errors) ; // Ok, $errors == [] else ; // Fail, $errors == [&#39;Virheviesti&#39;, &#39;Toinen virheviesti&#39; ...] . Yksittäisten arvojen validointi . $value = &#39;value&#39;; $errors = ( Pike Validation::makeValueValidator()) -&gt;rule(&#39;type&#39;, &#39;string&#39;) -&gt;rule(&#39;minLength&#39;, 1) -&gt;validate($value); if (!$errors) ; // Ok, $errors == [] else ; // Fail, $errors == [&#39;Virheviesti&#39;, &#39;Toinen virheviesti&#39; ...] . Custom one-time -validaattorit . Yksittäiselle validaattori-instanssille lisätä omia validaattoreita metodilla addRuleImpl(). . $v = Validation::makeValueValidator(); $v2 = Validation::makeValueValidator(); $v-&gt;addRuleImpl(&#39;myRule&#39;, function ($value, $arg1, $arg2) { return $value === $arg1 || $value === $arg2; }, &#39;%s is not %s nor %d&#39;); $errors = $v-&gt;rule(&#39;myRule&#39;, &#39;foo&#39;, 1) -&gt;validate(&#39;bar&#39;); // value is not foo nor 1 $v2-&gt;rule(&#39;myRule&#39;, ...) // PikeException, No implementation found for `myRule`. . Oletusvalidaattorit . rule(‘type’, ‘string’|’int’|’array’|’bool’|’float’|’object’ $expectedDataType) . Tarkastaa onko arvo tyyppiä $expectedDataType. . $valueValidator-&gt;rule(&#39;type&#39;, &#39;string&#39;)-&gt;validate([]); // Errors $valueValidator-&gt;rule(&#39;type&#39;, &#39;string&#39;)-&gt;validate(&#39;str&#39;); // Ok . rule(‘minLength’, int $minLength) . Tarkastaa onko arvo merkkijono tai countable, jonka mb_strlen() tai count() arvo on suurempi, tai yhtä suuri kuin $minLength. . $valueValidator-&gt;rule(&#39;minLength&#39;, 2)-&gt;validate(&#39;s&#39;); // Errors $valueValidator-&gt;rule(&#39;minLength&#39;, 2)-&gt;validate(&#39;st&#39;); // Ok $valueValidator-&gt;rule(&#39;minLength&#39;, 2)-&gt;validate([1]); // Errors $valueValidator-&gt;rule(&#39;minLength&#39;, 2)-&gt;validate([1,2]); // Ok . rule(‘maxLength’, int $maxLength) . Tarkastaa onko arvo merkkijono tai countable, jonka mb_strlen() tai count() arvo on pienempi, tai yhtä suuri kuin $maxLength. . $valueValidator-&gt;rule(&#39;maxLength&#39;, 2)-&gt;validate(&#39;str&#39;); // Errors $valueValidator-&gt;rule(&#39;maxLength&#39;, 2)-&gt;validate(&#39;st&#39;); // Ok $valueValidator-&gt;rule(&#39;maxLength&#39;, 2)-&gt;validate([1,2,3]); // Errors $valueValidator-&gt;rule(&#39;maxLength&#39;, 2)-&gt;validate([1,2]); // Ok . rule(‘min’, int $min) . Tarkastaa onko arvo numero, jonka arvo on enemmän, tai yhtä suuri kuin $min. . $valueValidator-&gt;rule(&#39;min&#39;, 5)-&gt;validate(1); // Errors $valueValidator-&gt;rule(&#39;min&#39;, 5)-&gt;validate(&#39;1&#39;); // Errors $valueValidator-&gt;rule(&#39;min&#39;, 5)-&gt;validate(&#39;foo&#39;); // Errors $valueValidator-&gt;rule(&#39;min&#39;, 5)-&gt;validate([]); // Errors $valueValidator-&gt;rule(&#39;min&#39;, 5)-&gt;validate(6); // Ok $valueValidator-&gt;rule(&#39;min&#39;, 5)-&gt;validate(&#39;6.0&#39;); // Ok $valueValidator-&gt;rule(&#39;min&#39;, 5)-&gt;validate(5); // Ok . rule(‘max’, int $max) . Tarkastaa onko arvo numero, jonka arvo on vähemmän, tai yhtä suuri kuin $max. . $valueValidator-&gt;rule(&#39;max&#39;, 5)-&gt;validate(6); // Errors $valueValidator-&gt;rule(&#39;max&#39;, 5)-&gt;validate(&#39;6&#39;); // Errors $valueValidator-&gt;rule(&#39;max&#39;, 5)-&gt;validate(&#39;foo&#39;); // Errors $valueValidator-&gt;rule(&#39;max&#39;, 5)-&gt;validate([]); // Errors $valueValidator-&gt;rule(&#39;max&#39;, 5)-&gt;validate(2); // Ok $valueValidator-&gt;rule(&#39;max&#39;, 5)-&gt;validate(&#39;2.0&#39;); // Ok $valueValidator-&gt;rule(&#39;max&#39;, 5)-&gt;validate(5); // Ok . rule(‘in’, array $listOfValues) . Tarkastaa löytyykö arvo taulukosta $listOfValues. . $valueValidator-&gt;rule(&#39;in&#39;, [1, 2])-&gt;validate(6); // Errors $valueValidator-&gt;rule(&#39;in&#39;, [1, 2])-&gt;validate(&#39;foo&#39;); // Errors $valueValidator-&gt;rule(&#39;in&#39;, [1, 2])-&gt;validate(&#39;2&#39;); // Errors (väärä tietotyyppi) $valueValidator-&gt;rule(&#39;in&#39;, [1, 2])-&gt;validate(2); // Ok . rule(‘identifier’) . Tarkastaa onko arvo merkkijono, joka: . Alkaa kirjaimella a-zA-Z tai _ | Sisältää ainoastaan a-zA-Z0-9 tai _ | . $valueValidator-&gt;rule(&#39;identifier&#39;)-&gt;validate([]); // Errors (ei string) $valueValidator-&gt;rule(&#39;identifier&#39;)-&gt;validate(&#39;Ab#&#39;); // Errors (non-ascii) $valueValidator-&gt;rule(&#39;identifier&#39;)-&gt;validate(&#39;Abä&#39;); // Errors (non-ascii) $valueValidator-&gt;rule(&#39;identifier&#39;)-&gt;validate(&#39;4foo&#39;); // Errors (alkaa numerolla) $valueValidator-&gt;rule(&#39;identifier&#39;)-&gt;validate(&#39;Abc&#39;); // Ok $valueValidator-&gt;rule(&#39;identifier&#39;)-&gt;validate(&#39;Ab_c&#39;); // Ok $valueValidator-&gt;rule(&#39;identifier&#39;)-&gt;validate(&#39;Ab5&#39;); // Ok .",
    "url": "https://ut4.github.io/pike/validation.html",
    "relUrl": "/validation.html"
  }
  
}